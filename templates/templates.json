[
  {
    "name": "Form Validation",
    "description": "JavaScript form validation with error handling.",
    "language": "JavaScript",
    "code_type": "Function",
    "code": "function validateForm(formData, rules, messages = {}) {\n    let isValid = true;\n    \n    // Helper function to mark a field as invalid\n    function markInvalid(inputField, message) {\n        // Add error class\n        inputField.classList.add('is-invalid');\n        \n        // Find or create error message element\n        let errorElement = inputField.parentNode.querySelector('.invalid-feedback');\n        if (!errorElement) {\n            errorElement = document.createElement('div');\n            errorElement.className = 'invalid-feedback';\n            inputField.parentNode.appendChild(errorElement);\n        }\n        \n        // Set error message\n        errorElement.textContent = message;\n    }\n    \n    // Loop through each field in the rules\n    for (const fieldName in rules) {\n        const field_rules = rules[fieldName];\n        const input_field = document.querySelector(`[name=${fieldName}]`);\n        \n        if (!input_field) {\n            console.error(`Field ${fieldName} not found in the form`);\n            continue;\n        }\n        \n        // Clear previous errors\n        input_field.classList.remove('is-invalid');\n        const errorElement = input_field.parentNode.querySelector('.invalid-feedback');\n        if (errorElement) {\n            errorElement.remove();\n        }\n        \n        // Get field value\n        const value = formData.get(fieldName) || '';\n        \n        // Check if required\n        if (field_rules.required && !value) {\n            const message = messages[fieldName]?.required || `${fieldName} is required`;\n            markInvalid(input_field, message);\n            isValid = false;\n            continue;\n        }\n        \n        // Skip other validations if empty and not required\n        if (!value && !field_rules.required) {\n            continue;\n        }\n        \n        // Check minimum length\n        if (field_rules.minLength && value.length < field_rules.minLength) {\n            const message = messages[fieldName]?.minLength || \n                `${fieldName} must be at least ${field_rules.minLength} characters`;\n            markInvalid(input_field, message);\n            isValid = false;\n            continue;\n        }\n        \n        // Check maximum length\n        if (field_rules.maxLength && value.length > field_rules.maxLength) {\n            const message = messages[fieldName]?.maxLength || \n                `${fieldName} must be at most ${field_rules.maxLength} characters`;\n            markInvalid(input_field, message);\n            isValid = false;\n            continue;\n        }\n        \n        // Check pattern\n        if (field_rules.pattern && !field_rules.pattern.test(value)) {\n            const message = messages[fieldName]?.pattern || \n                `${fieldName} does not match the required pattern`;\n            markInvalid(input_field, message);\n            isValid = false;\n            continue;\n        }\n        \n        // Check if email\n        if (field_rules.email && !/^\\S+@\\S+\\.\\S+$/.test(value)) {\n            const message = messages[fieldName]?.email || \n                `${fieldName} must be a valid email address`;\n            markInvalid(input_field, message);\n            isValid = false;\n            continue;\n        }\n        \n        // Check custom validator\n        if (field_rules.custom && typeof field_rules.custom === 'function') {\n            const customResult = field_rules.custom(value);\n            if (customResult !== true) {\n                const message = typeof customResult === 'string' ? customResult : \n                    messages[fieldName]?.custom || `${fieldName} is invalid`;\n                markInvalid(input_field, message);\n                isValid = false;\n                continue;\n            }\n        }\n    }\n    \n    return isValid;\n}\n\n// Example usage:\n// const formData = new FormData(document.querySelector('form'));\n// const rules = {\n//     email: { required: true, email: true },\n//     password: { required: true, minLength: 8 }\n// };\n// validateForm(formData, rules);",
    "id": "Form_Validation_1744063696",
    "created_at": "2025-04-07T16:08:16.308599",
    "updated_at": "2025-04-07T16:08:16.308599"
  },
  {
    "name": "Python Database Connection",
    "description": "A template for connecting to a database with error handling and connection pooling.",
    "language": "Python",
    "code_type": "Class",
    "code": "import os\nimport logging\nfrom typing import Dict, Any, Optional, List\nimport sqlite3\nfrom contextlib import contextmanager\n\nclass DatabaseManager:\n    # Database connection manager with connection pooling\n    \n    _instance = None\n    \n    def __new__(cls, *args, **kwargs):\n        \"\"\"Implement singleton pattern.\"\"\"\n        if cls._instance is None:\n            cls._instance = super(DatabaseManager, cls).__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    \n    def __init__(self, db_path: Optional[str] = None):\n        \"\"\"Initialize the database manager with connection config.\"\"\"\n        # Only initialize once (singleton pattern)\n        if hasattr(self, '_initialized') and self._initialized:\n            return\n            \n        # Set up logging\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n        \n        # Set database path\n        self.db_path = db_path or os.getenv('DB_PATH', 'database.sqlite')\n        \n        # Flag as initialized\n        self._initialized = True\n        \n        # Initialize database\n        self._init_db()\n    \n    def _init_db(self) -> None:\n        \"\"\"Initialize the database if it doesn't exist.\"\"\"\n        try:\n            with self.get_connection() as conn:\n                # Create tables here if needed\n                pass\n                \n            self.logger.info(f\"Database initialized: {self.db_path}\")\n        except Exception as e:\n            self.logger.error(f\"Error initializing database: {str(e)}\")\n            raise\n    \n    @contextmanager\n    def get_connection(self):\n        \"\"\"Get a database connection.\"\"\"\n        conn = None\n        try:\n            conn = sqlite3.connect(self.db_path)\n            conn.row_factory = sqlite3.Row  # Return rows as dictionaries\n            yield conn\n        except Exception as e:\n            self.logger.error(f\"Database connection error: {str(e)}\")\n            raise\n        finally:\n            if conn:\n                conn.close()\n    \n    def execute_query(self, query: str, params: Optional[tuple] = None) -> List[Dict[str, Any]]:\n        \"\"\"Execute a query and return results.\"\"\"\n        try:\n            with self.get_connection() as conn:\n                cursor = conn.cursor()\n                cursor.execute(query, params or ())\n                conn.commit()\n                \n                # Convert results to dictionaries\n                if cursor.description:\n                    columns = [col[0] for col in cursor.description]\n                    return [dict(zip(columns, row)) for row in cursor.fetchall()]\n                return []\n        except Exception as e:\n            self.logger.error(f\"Query execution error: {str(e)}\")\n            raise\n    \n    def execute_many(self, query: str, params_list: List[tuple]) -> None:\n        \"\"\"Execute a query with multiple parameter sets.\"\"\"\n        try:\n            with self.get_connection() as conn:\n                cursor = conn.cursor()\n                cursor.executemany(query, params_list)\n                conn.commit()\n        except Exception as e:\n            self.logger.error(f\"Batch query execution error: {str(e)}\")\n            raise\n    \n    def insert_one(self, table: str, data: Dict[str, Any]) -> int:\n        \"\"\"Insert a single record and return the ID.\"\"\"\n        columns = ', '.join(data.keys())\n        placeholders = ', '.join(['?' for _ in data])\n        query = f\"INSERT INTO {table} ({columns}) VALUES ({placeholders})\"\n        \n        try:\n            with self.get_connection() as conn:\n                cursor = conn.cursor()\n                cursor.execute(query, tuple(data.values()))\n                conn.commit()\n                return cursor.lastrowid\n        except Exception as e:\n            self.logger.error(f\"Insert error: {str(e)}\")\n            raise\n    \n    def get_by_id(self, table: str, id_value: int, id_column: str = 'id') -> Optional[Dict[str, Any]]:\n        \"\"\"Get a record by ID.\"\"\"\n        query = f\"SELECT * FROM {table} WHERE {id_column} = ?\"\n        \n        try:\n            results = self.execute_query(query, (id_value,))\n            return results[0] if results else None\n        except Exception as e:\n            self.logger.error(f\"Get by ID error: {str(e)}\")\n            raise",
    "id": "Python_Database_Connection_1744063696",
    "created_at": "2025-04-07T16:08:16.308792",
    "updated_at": "2025-04-07T16:08:16.308792"
  }
]